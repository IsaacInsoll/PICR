import { readFile, writeFile, mkdir } from 'node:fs/promises';
import { fileURLToPath } from 'node:url';
import path from 'node:path';
import vm from 'node:vm';
import * as ts from 'typescript';
import { createRequire } from 'node:module';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const repoRoot = path.resolve(__dirname, '..');
const require = createRequire(import.meta.url);

const buildHeader = (target: string) => `// This file is autogenerated by: node scripts/generate-fonts.ts
// Do not edit directly. Update shared/branding/fontRegistry.ts instead.
// Target: ${target}
\n`;

const toKebab = (value: string) =>
  value
    .replace(/([a-z0-9])([A-Z])/g, '$1-$2')
    .replace(/\s+/g, '-')
    .toLowerCase();

const fontsourceOverrides: Record<string, string> = {
  'jetbrains-mono': '@fontsource/jetbrains-mono',
};

const fontsourcePackage = (font: { key: string; label: string }) => {
  if (font.key === 'default') return '@fontsource/signika';
  const override = fontsourceOverrides[font.key];
  if (override) return override;
  return `@fontsource/${toKebab(font.label)}`;
};

const buildWebFonts = (fontRegistry: Array<any>) => {
  const imports = new Set<string>();
  const fontFamilies: Record<string, string> = { default: 'Signika' };

  fontRegistry.forEach((font) => {
    if (font.key === 'default') return;
    const pkg = fontsourcePackage(font);
    font.weights.forEach((weight: number) => {
      imports.add(`import '${pkg}/${weight}.css';`);
    });
    fontFamilies[font.key] = font.label;
  });

  [400, 600, 700].forEach((weight) => {
    imports.add(`import '@fontsource/signika/${weight}.css';`);
  });
  [400, 500, 700].forEach((weight) => {
    imports.add(`import '@fontsource/roboto/${weight}.css';`);
  });

  return `${buildHeader('frontend')}${Array.from(imports).join('\n')}

export const fontFamilies = ${JSON.stringify(fontFamilies, null, 2)} as const;
`;
};

const buildAppFonts = (fontRegistry: Array<any>) => {
  const lines: string[] = [];
  const fontFiles: Record<string, string> = {};
  const fontWeightsByKey: Record<string, number[]> = {
    default: [400, 600, 700],
  };

  fontRegistry.forEach((font) => {
    if (font.key === 'default') return;
    fontWeightsByKey[font.key] = font.weights;
    font.weights.forEach((weight: number) => {
      const filename = `${font.key}-${weight}.ttf`;
      const varName = `${font.key.replace(/[^a-zA-Z0-9]/g, '_')}_${weight}`;
      lines.push(
        `const ${varName} = require('./assets/fonts/${filename}');`,
      );
      fontFiles[`${font.key}-${weight}`] = varName;
    });
  });

  [400, 500, 700].forEach((weight) => {
    const filename = `roboto-${weight}.ttf`;
    lines.push(`const roboto_${weight} = require('./assets/fonts/${filename}');`);
    fontFiles[`roboto-${weight}`] = `roboto_${weight}`;
  });

  return `${buildHeader('app')}${lines.join('\n')}

export const fontFiles = {
${Object.entries(fontFiles)
  .map(([key, value]) => `  '${key}': ${value},`)
  .join('\n')}
} as const;

export const fontWeightsByKey = ${JSON.stringify(
    fontWeightsByKey,
    null,
    2,
  )} as const;
`;
};

const loadFontRegistry = async () => {
  const modulePath = path.join(repoRoot, 'shared/branding/fontRegistry.ts');
  const source = await readFile(modulePath, 'utf8');
  const transpiled = ts.transpileModule(source, {
    compilerOptions: {
      module: ts.ModuleKind.CommonJS,
      target: ts.ScriptTarget.ES2019,
    },
  });
  const module = { exports: {} as Record<string, any> };
  const context = vm.createContext({
    module,
    exports: module.exports,
    require,
  });
  vm.runInContext(transpiled.outputText, context, { filename: modulePath });
  const fontRegistry = (module.exports as { fontRegistry?: unknown }).fontRegistry;
  if (!Array.isArray(fontRegistry)) {
    throw new Error('fontRegistry export not found or invalid.');
  }
  return fontRegistry;
};

type GitHubFile = { name: string; download_url: string };

const copyAppFonts = async (fontRegistry: Array<any>) => {
  const targetRoot = path.join(repoRoot, 'app/src/assets/fonts');
  await mkdir(targetRoot, { recursive: true });

  const familyCache = new Map<string, GitHubFile[]>();

  const weightNameMap: Record<number, string[]> = {
    100: ['Thin'],
    200: ['ExtraLight', 'UltraLight'],
    300: ['Light'],
    400: ['Regular'],
    500: ['Medium'],
    600: ['SemiBold', 'DemiBold'],
    700: ['Bold'],
    800: ['ExtraBold', 'UltraBold'],
    900: ['Black', 'Heavy'],
  };

  const pickStaticFile = (files: GitHubFile[], weight: number) => {
    const names = weightNameMap[weight] ?? [];
    const candidates = files.filter((file) => file.name.includes('static'));
    for (const name of names) {
      const match = candidates.find(
        (file) =>
          file.name.includes(`-${name}.ttf`) &&
          !file.name.toLowerCase().includes('italic'),
      );
      if (match) return match;
    }
    return null;
  };

  const pickVariableFile = (files: GitHubFile[]) => {
    return (
      files.find(
        (file) =>
          file.name.toLowerCase().includes('variablefont') &&
          !file.name.toLowerCase().includes('italic'),
      ) ??
      files.find((file) => !file.name.toLowerCase().includes('italic')) ??
      files[0]
    );
  };

  const slugifyFamily = (family: string) =>
    family.toLowerCase().replace(/[^a-z0-9]/g, '');

  const fetchGitHubDir = async (dir: string): Promise<GitHubFile[] | null> => {
    const url = `https://api.github.com/repos/google/fonts/contents/${dir}?ref=main`;
    const res = await fetch(url, {
      headers: {
        'user-agent': 'PICR font downloader',
        accept: 'application/vnd.github+json',
      },
    });
    if (!res.ok) return null;
    const data = (await res.json()) as Array<{
      name: string;
      type: 'file' | 'dir';
      download_url?: string;
    }>;
    return data
      .filter((item) => item.type === 'file' && item.download_url)
      .map((item) => ({
        name: item.name,
        download_url: item.download_url as string,
      }));
  };

  const fetchGitHubDirEntries = async (
    dir: string,
  ): Promise<Array<{ name: string; type: 'file' | 'dir'; download_url?: string }> | null> => {
    const url = `https://api.github.com/repos/google/fonts/contents/${dir}?ref=main`;
    const res = await fetch(url, {
      headers: {
        'user-agent': 'PICR font downloader',
        accept: 'application/vnd.github+json',
      },
    });
    if (!res.ok) return null;
    return (await res.json()) as Array<{
      name: string;
      type: 'file' | 'dir';
      download_url?: string;
    }>;
  };

  const getGitHubFontFiles = async (family: string): Promise<GitHubFile[]> => {
    const cached = familyCache.get(family);
    if (cached) return cached;
    const slug = slugifyFamily(family);
    const basePaths = ['ofl', 'apache', 'ufl'];
    for (const base of basePaths) {
      const dir = `${base}/${slug}`;
      const entries = await fetchGitHubDirEntries(dir);
      if (!entries) continue;
      const files: GitHubFile[] = entries
        .filter((item) => item.type === 'file' && item.download_url)
        .map((item) => ({
          name: item.name,
          download_url: item.download_url as string,
        }));
      const staticDir = entries.find(
        (item) => item.type === 'dir' && item.name === 'static',
      );
      if (staticDir) {
        const staticFiles = await fetchGitHubDir(`${dir}/static`);
        if (staticFiles) {
          files.push(
            ...staticFiles.map((file) => ({
              ...file,
              name: `static/${file.name}`,
            })),
          );
        }
      }
      const ttfFiles = files.filter((file) =>
        file.name.toLowerCase().endsWith('.ttf'),
      );
      if (ttfFiles.length > 0) {
        familyCache.set(family, ttfFiles);
        console.log(`Fonts: found ${ttfFiles.length} TTFs for ${family}`);
        return ttfFiles;
      }
    }
    throw new Error(`No TTF files found for family ${family}`);
  };

  const ensureFileForWeight = async (
    font: { key: string; label: string },
    weight: number,
    targetName: string,
  ) => {
    const familyFiles = await getGitHubFontFiles(font.label);
    const staticMatch = pickStaticFile(familyFiles, weight);
    const match = staticMatch ?? pickVariableFile(familyFiles);
    if (!match) {
      throw new Error(
        `No TTF file found for ${font.key} weight ${weight} in Google Fonts repo`,
      );
    }
    const targetPath = path.join(targetRoot, targetName);
    console.log(`Fonts: downloading ${font.label} ${weight} -> ${targetName}`);
    const res = await fetch(match.download_url, {
      headers: { 'user-agent': 'PICR font downloader' },
    });
    if (!res.ok) {
      throw new Error(
        `Failed to download ${match.download_url} (${res.status})`,
      );
    }
    const buffer = Buffer.from(await res.arrayBuffer());
    await writeFile(targetPath, buffer);
  };

  const fontsToCopy = fontRegistry.filter((font) => font.key !== 'default');
  for (const font of fontsToCopy) {
    if (!font) continue;
    console.log(`Fonts: processing ${font.label}`);
    for (const weight of font.weights ?? []) {
      const targetName = `${font.key}-${weight}.ttf`;
      await ensureFileForWeight(font, weight, targetName);
    }
  }

  const robotoFont = { key: 'roboto', label: 'Roboto', weights: [400, 500, 700] };
  console.log('Fonts: processing Roboto');
  for (const weight of robotoFont.weights) {
    const targetName = `${robotoFont.key}-${weight}.ttf`;
    await ensureFileForWeight(robotoFont, weight, targetName);
  }
};

const run = async () => {
  const fontRegistry = await loadFontRegistry();

  const webPath = path.join(repoRoot, 'frontend/src/fonts.generated.ts');
  const appPath = path.join(repoRoot, 'app/src/fonts.generated.ts');

  await writeFile(webPath, buildWebFonts(fontRegistry), 'utf8');
  await writeFile(appPath, buildAppFonts(fontRegistry), 'utf8');

  await copyAppFonts(fontRegistry);
};

run().catch((error) => {
  console.error('Failed to generate font manifests:', error);
  process.exit(1);
});
